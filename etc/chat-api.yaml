Name: chat-rag
Host: 0.0.0.0
Port: 8888

# Logging configuration
Log:
  LogFilePath: "logs/"

PreciseContextConfig:
  EnableEnvDetailsFilter: true
  # Control which agents in which modes cannot use ModesChange
  DisabledModesChangeAgents:
    strict:
      - "strict"
      - "requirements"
      - "architect"
      - "task"
      - "review"
      - "code"
    vibe:
      - "review"
  
  # Dynamic configuration for task description content
  TaskContentReplaceRule:
    vibeplus: # Group name, used to distinguish different scenarios
      # Specify which agents are effective, the structure here can reuse DisabledModesChangeAgents
      # If not configured, all will be effective, be careful!
      valid_agents:
        vibe:
          - "architect"
          - "code"
          - "ask"
      match_keys:
        "%command-vibeplus-propsal%": |
          **护栏原则**

          - 优先采用最直接、最小化的实现方式，仅在明确需要或被要求时添加复杂性。
          - 保持变更范围是紧密围绕用户预期结果展开的。
          - VibePlus约束或最佳实践，请一定要参考**VibePlus约束和最佳实践**。

          **步骤**
          1. 选择一个唯一的动词引导的`change-id`，并在`vibeplus/changes/<id>/`下构建`proposal.md`、`tasks.md`和`design.md`（需要时）。
          2. 将变更映射到具体能力或需求，将多范围工作分解为具有清晰关系和顺序的不同规格增量。
          3. 当解决方案跨越多个系统、引入新模式时，在`design.md`中写明架构设计考量。
          4. 在`vibeplus/changes/<id>/specs/<capability>/spec.md`（每个能力一个文件夹）中起草规格增量，使用`## ADDED|MODIFIED|REMOVED Requirements`，每个需求至少包含一个`#### Scenario:`，并在关联时交叉引用。
          5. 将`tasks.md`起草为有序的小型可验证工作项目列表，这些项目提供用户可见的进度，包括验证（单元测试即可），并突出依赖项或可并行的工作。

          **VibePlus约束和最佳实践** 

          ~~~markdown
          # VibePlus 指南

          使用 VibePlus 进行规范驱动开发的 AI 编码助手的说明。

          ## 三阶段工作流程

          ### 阶段 1：创建变更
          在以下情况下需要创建提案：
          - 添加功能或特性
          - 进行破坏性变更（API、架构）
          - 更改架构或模式
          - 优化性能（改变行为）
          - 更新安全模式

          触发器（示例）：
          - "帮我创建一个变更提案"
          - "帮我规划一个变更"
          - "帮我创建一个提案"
          - "我想创建一个规范提案"
          - "我想创建一个规范"

          跳过提案的情况：
          - 错误修复（恢复预期行为）
          - 拼写错误、格式、注释
          - 依赖更新（非破坏性）
          - 配置更改
          - 现有行为的测试

          **工作流程**
          1. 选择一个唯一的动词引导的 `change-id`，并在 `vibeplus/changes/<id>/` 下构建 `proposal.md`, `tasks.md`, 可选的 `design.md` 和规范增量。
          2. 使用 `## ADDED|MODIFIED|REMOVED Requirements` 起草规范增量，每个需求至少包含一个 `#### Scenario:`。

          ## 在任何任务之前

          **上下文检查清单：**
          - [ ] 阅读 `specs/[capability]/spec.md` 中的相关规范
          - [ ] 检查 `changes/` 中待处理的变更是否有冲突

          **创建规范之前：**
          - 始终检查功能是否已存在
          - 优先修改现有规范而不是创建重复项
          - 如果请求不明确，在构建脚手架前询问 1-2 个澄清问题

          ## 目录结构

          ```
          vibeplus/
          ├── specs/                  # 当前事实 - 已构建的内容
          │   └── [capability]/       # 单一/专注功能点
          │       ├── spec.md         # 需求和场景
          │       └── design.md       # 技术设计
          ├── changes/                # 提案 - 具体变更的内容
          │   ├── [change-name]/
          │   │   ├── proposal.md     # 原因、内容、影响
          │   │   ├── tasks.md        # 实施清单
          │   │   ├── design.md       # 技术决策（可选；参见标准）
          │   │   └── specs/          # 增量变更
          │   │       └── [capability]/
          │   │           └── spec.md # ADDED/MODIFIED/REMOVED
          │   └── archive/            # 已完成的变更
          ```

          ## 创建变更提案

          ### 决策树

          ```
          新请求？
          ├─ 恢复规范行为的错误修复？→ 直接修复
          ├─ 拼写错误/格式/注释？→ 直接修复
          ├─ 新功能/能力？→ 创建提案
          ├─ 破坏性变更？→ 创建提案
          ├─ 架构变更？→ 创建提案
          └─ 不明确？→ 创建提案（更安全）
          ```

          ### 提案结构

          1. **创建目录：** `changes/[change-id]/`（短横线命名法，动词引导，唯一）

          2. **编写 proposal.md:**
          ```markdown
          # 变更：[变更的简要描述]

          ## 原因
          [关于问题/机会的 1-2 句话]

          ## 变更内容
          - [变更的要点列表]
          - [用 **BREAKING** 标记破坏性变更]

          ## 影响
          - 受影响的规范：[列出功能]
          - 受影响的代码：[关键文件/系统]
          例如：
          - **受影响的规范**：招聘管理 (Recruitment Management)
          - **受影响的代码**：
              - `hrms/static/api/menus.json`: 新增菜单项。
              - `hrms/views/`: 新增页面文件。
              - `hrms/service/candidate.go#L10-L20` & `hrms/handler/candidate.go#L10`: 新增或更新查询逻辑。
          ```

          3. **创建规范增量：** `specs/[capability]/spec.md`
          ```markdown
          ## ADDED Requirements
          ### Requirement: 新功能
          系统应提供...

          #### Scenario: 成功案例
          - **WHEN** 用户执行操作
          - **THEN** 预期结果

          ## MODIFIED Requirements
          ### Requirement: 现有功能
          [完整的修改后的需求]

          ## REMOVED Requirements
          ### Requirement: 旧功能
          **原因**：[为什么移除]
          **迁移**：[如何处理]
          ```
          如果多个功能受到影响，请在 `changes/[change-id]/specs/<capability>/spec.md` 下创建多个增量文件——每个功能一个。

          4. **创建 tasks.md:**
          ```markdown
          ## 1. 实施
          - [ ] 1.1 后端：在 `service/candidate.go#L10-L20` 中实现联合查询逻辑，支持按候选人姓名 (`name`) 和面试官姓名 (`staff_name`) 筛选。需处理 `Candidate` 表与 `Staff` 表的关联。
          - [ ] 1.2 前端：更新 `views/interview_record_manage.html#L10-L20` 中的 JS 逻辑，适配新的搜索 API 和评价更新 API。
          - [ ] 1.3 配置：更新 `hrms/static/api/menus.json#L10`，在“招聘管理”下添加“面试记录”菜单项。
          ```

          5. **在需要时创建 design.md:**
          如果满足以下任何条件，请创建 `design.md`；否则省略它：
          - 变更（多个服务/模块）或新架构模式
          - 新的外部依赖或重要的数据模型变更
          - 安全性、性能或任务复杂性较高

          最小的 `design.md` 框架：
          ```markdown
          ## 上下文
          [背景、约束、利益相关者]

          ## 目标 / 非目标
          - 目标：[...]
          - 非目标：[...]

          ## 决策
          - 决策：[内容和原因]
          - 考虑的替代方案：[选项 + 理由]

          ## 风险 / 权衡
          - [风险] → 缓解措施

          ## 迁移计划
          [步骤、回滚]

          ## 开放问题
          - [...]
          ```

          ## 规范文件格式

          ### 关键：场景格式

          **正确**（使用 #### 标题）：
          ```markdown
          #### Scenario: 用户登录成功
          - **WHEN** 提供有效凭据
          - **THEN** 返回 JWT 令牌
          ```

          **错误**（不要使用项目符号或粗体）：
          ```markdown
          - **Scenario: 用户登录**  ❌
          **Scenario**: 用户登录     ❌
          ### Scenario: 用户登录      ❌
          ```

          每个需求必须至少有一个场景。

          ### 需求措辞
          - 对规范性要求使用 SHALL/MUST（除非有意非规范性，否则避免使用 should/may）

          ### 增量操作

          - `## ADDED Requirements` - 新功能
          - `## MODIFIED Requirements` - 变更的行为
          - `## REMOVED Requirements` - 弃用的功能
          - `## RENAMED Requirements` - 名称变更

          标题使用 `trim(header)` 匹配 - 忽略空白字符。

          #### 何时使用 ADDED vs MODIFIED
          - ADDED：引入可以独立作为需求的新功能或子功能。当变更正交（例如添加"斜杠命令配置"）而不是改变现有需求的语义时，优先使用 ADDED。
          - MODIFIED：更改现有需求的行为、范围或验收标准。始终粘贴完整的更新需求内容（标题 + 所有场景）。归档器将用您在此处提供的内容替换整个需求；部分增量将丢失之前的详细信息。
          - RENAMED：仅在名称更改时使用。如果您还更改行为，请使用 RENAMED（名称）加上 MODIFIED（内容）引用新名称。

          常见陷阱：使用 MODIFIED 添加新关注点而不包含之前的文本。这会导致在归档时丢失详细信息。如果您没有明确更改现有需求，请在 ADDED 下添加新需求。

          正确编写 MODIFIED 需求：
          1) 在 `vibeplus/specs/<capability>/spec.md` 中找到现有需求。
          2) 复制整个需求块（从 `### Requirement: ...` 到其场景）。
          3) 将其粘贴到 `## MODIFIED Requirements` 下并编辑以反映新行为。
          4) 确保标题文本完全匹配（不区分空白字符）并至少保留一个 `#### Scenario:`。

          RENAMED 示例：
          ```markdown
          ## RENAMED Requirements
          - FROM: `### Requirement: 登录`
          - TO: `### Requirement: 用户认证`
          ```

          ## 故障排除

          ### 常见错误

          **"变更必须至少有一个增量"**
          - 检查 `changes/[name]/specs/` 存在且包含 .md 文件
          - 验证文件具有操作前缀（## ADDED Requirements）

          **"需求必须至少有一个场景"**
          - 检查场景使用 `#### Scenario:` 格式（4 个井号）
          - 不要对场景标题使用项目符号或粗体

          **静默场景解析失败**
          - 需要精确格式：`#### Scenario: 名称`

          ## 快速路径脚本

          ```bash
          # 1) 选择变更 id 并构建脚手架
          CHANGE=add-two-factor-auth
          mkdir -p vibeplus/changes/$CHANGE/{specs/auth}
          printf "## 原因\n...\n\n## 变更内容\n- ...\n\n## 影响\n- ...\n" > vibeplus/changes/$CHANGE/proposal.md
          printf "## 1. 实施\n- [ ] 1.1 ...\n" > vibeplus/changes/$CHANGE/tasks.md

          # 2) 添加增量（示例）
          cat > vibeplus/changes/$CHANGE/specs/auth/spec.md << 'EOF'
          ## ADDED Requirements
          ### Requirement: 双因素认证
          用户在登录期间必须提供第二个因素。

          #### Scenario: 需要一次性密码
          - **WHEN** 提供有效凭据
          - **THEN** 需要一次性密码挑战
          EOF
          ```

          ## 多功能示例

          ```
          vibeplus/changes/add-2fa-notify/
          ├── proposal.md
          ├── tasks.md
          └── specs/
              ├── auth/
              │   └── spec.md   # ADDED: 双因素认证
              └── notifications/
                  └── spec.md   # ADDED: 一次性密码邮件通知
          ```

          auth/spec.md
          ```markdown
          ## ADDED Requirements
          ### Requirement: 双因素认证
          ...
          ```

          notifications/spec.md
          ```markdown
          ## ADDED Requirements
          ### Requirement: 一次性密码邮件通知
          ...
          ```

          ## 最佳实践

          ### 清晰引用
          - 使用 `file.ts:42` 格式表示代码位置
          - 引用规范为 `specs/auth/spec.md`
          - 链接相关变更和 PR

          ### 功能命名
          - 使用动词-名词：`user-auth`, `payment-capture`
          - 每个功能单一目的
          - 10 分钟可理解规则
          - 如果描述需要 "AND"，则拆分

          ### 变更 ID 命名
          - 使用短横线命名法，简短且描述性：`add-two-factor-auth`
          - 优先使用动词引导前缀：`add-`, `update-`, `remove-`, `refactor-`
          - 确保唯一性；如果已被占用，附加 `-2`, `-3` 等


          ## 错误恢复

          ### 变更冲突
          1. 检查是否有重叠的规范
          2. 与变更所有者协调
          3. 考虑合并提案

          ### 验证失败
          1. 验证规范文件格式
          2. 确保场景格式正确

          ### 缺少上下文
          1. 检查相关规范
          2. 查看最近的归档
          3. 询问澄清问题

          ## 快速参考

          ### 阶段指示器
          - `changes/` - 已提议，尚未构建
          - `specs/` - 已构建和部署
          - `archive/` - 已完成的变更

          ### 文件用途
          - `proposal.md` - 提案原因和具体内容
          - `tasks.md` - 实施步骤
          - `design.md` - 技术决策
          - `spec.md` - 需求和行为
          ~~~

          记住：规范是事实。变更是提案。保持它们同步。

    scene1: # Group name, used to distinguish different scenarios
      # Specify which agents are effective, the structure here can reuse DisabledModesChangeAgents
      # If not configured, all will be effective, be careful!
      valid_agents:
        strict: # Mode name
          - "requirements" # agent name
          - "architect"
        vibe:
          - "review"
          - "code"

      skip_key: "%skip_key%" # If content contains this flag, skip processing directly

      match_keys:
        key1: |
          "The content you want to replace key1"
        key2: |
          "The content you want to replace key2"

  AgentsMatch:
    - agent: "strict"
      key: "a strict strategic workflow controller"
    - agent: "requirements"
      key: "an experienced requirements analyst specializing"
    - agent: "code"
      key: "a highly skilled software engineer"
    - agent: "architect"
      key: "an experienced technical leader"
    - agent: "task"
      key: "a project manager specializing in task decomposition"
    - agent: "test"
      key: "a professional testing engineer"
    - agent: "testguide"
      key: "a senior architect and testing expert"
    - agent: "review"
      key: "a code review expert skilled at analyzing issues"

# Department configuration
DepartmentApiEndpoint: "http://localhost:1234/work_id?work_id="

# Models supported by function calling
LLM:
  # Endpoint: "https://zgsm.sangfor.com/chat-rag/api/v1/chat/completions"
  # Endpoint: "http://zgsm.sangfor.com/oneapi/v1/chat/completions"
  Endpoint: "http://127.0.0.1:30616/chat-rag/api/v1/chat/completions"

LLMTimeout:
  # 单次连续空闲阈值（毫秒），默认 30000ms
  IdleTimeoutMs: 30000
  # 总空闲预算（毫秒），跨重试/降级累计空闲时长上限，默认 30000ms
  TotalIdleTimeoutMs: 30000

Redis:
  Addr: "127.0.0.1:6379"

# Semantic API configuration
Tools:
  # Control which agents in which modes cannot use tools
  DisabledAgents:
    strict:
      - "strict"
      - "task"

  # 新的通用工具配置结构
  GenericTools:
    # 语义搜索工具
    - name: "codebase_search"
      description: |
        Description: Find files most relevant to the search query.
        This is a semantic search tool, so the query should ask for something semantically matching what is needed.
        If it makes sense to only search in a particular directory, please specify it in the path parameter.
        Unless there is a clear reason to use your own search query, please just reuse the user's exact query with their wording.
        Their exact wording/phrasing can often be helpful for the semantic search query. 
        Keeping the same exact question format can also be helpful.
        IMPORTANT: Queries MUST be in English. Translate non-English queries before searching.
        When you need to search for relevant codes, use this tool first.

        Parameters:
        - query: (required) The search query to find relevant code. You should reuse the user's exact query/most recent message with their wording unless there is a clear reason not to.
        - path: (optional) The path to the directory to search in relative to the current working directory. This parameter should only be a directory path, file paths are not supported. Defaults to the current working directory.
        Usage:
        <codebase_search>
        <query>Your natural language query here</query>
        <path>Path to the directory to search in (optional)</path>
        </codebase_search>

        Example: Searching for functions related to user authentication
        <codebase_search>
        <query>User login and password hashing</query>
        <path>/path/to/directory</path>
        </codebase_search>
      
      capability: |
        - You can use codebase_search to perform semantic-aware searches across your codebase, 
        returning conceptually relevant code snippets based on meaning rather than exact text matches. 
        This is particularly powerful for discovering related functionality, exploring unfamiliar code architecture, 
        or locating implementations when you only understand the purpose but not the specific syntax. 
        For optimal efficiency, always try codebase_search first as it delivers more focused results with lower token consumption. 
        Reserve other tools for cases where you need literal pattern matching or precise line-by-line analysis of file contents. 
        This balanced approach ensures you get the right search method for each scenario - semantic discovery through codebase_search when possible, 
        falling back to exhaustive text search via other tools only when necessary.

      rule: |
        - Before reading the file directly, you can try to use codebase_search

      # API端点配置
      endpoints:
        search: "http://123.58.64.57:30080/codebase-embedder/api/v1/search/semantic"
        ready: "http://123.58.64.57:30080/codebase-embedder/api/v1/embeddings/summary"
      
      # 请求方法
      method: "POST"
      
      # 参数定义
      parameters:
        - name: "query"
          type: "string"
          description: "The search query to find relevant code. You should reuse the user's exact query/most recent message with their wording unless there is a clear reason not to."
          required: true
          source: "llm"  
          
        - name: "path"
          type: "string"
          description: "The path to the directory to search in relative to the current working directory. This parameter should only be a directory path, file paths are not supported. Defaults to the current working directory."
          required: false
          source: "llm"
          
        - name: "topK"
          type: "integer"
          description: "Number of results to return"
          required: false
          default: 50
          source: "manual"
          
        - name: "score"
          type: "float"
          description: "Similarity score threshold"
          required: false
          default: 0.7
          source: "manual"
              
    # 代码定义搜索工具
    - name: "search_definitions"
      description: |
        Description: Retrieve the complete definitions and implementations of one or more symbols defined within the project (not external libraries), or of symbols referenced within the code that you need to understand in context.
        This tool allows you to quickly and accurately retrieve the original definitions and full implementations of all symbols—such as constants, structs, interfaces, functions, methods, and classes—as well as their values. It can also obtain the definitions and implementations of all external symbols within a specific code block, or of a single symbol, whether used within the same file or across other files, providing complete information to facilitate understanding of the code logic.
        Compared with using the search_files tool or reading files directly, this tool is significantly more efficient, accurate, and token-friendly, allowing you to obtain results more quickly, accurately, and with lower token cost. It provides comprehensive information to help you fully understand the code logic and referenced symbols, making it the preferred method for retrieving symbol definitions.
        Key Rule:
        - Always call this tool first if the code snippet references any symbol that is not fully defined within the snippet itself.
        - This tool ensures you analyze real implementations, not incomplete or assumed logic.
        Note: 
        1. This tool only applies to seven languages: Java, Go, Python, C, CPP, JavaScript, and TypeScript. Other languages are not applicable.
        2. This tool is more efficient and uses fewer tokens than search_files tool or directly reading files to obtain symbol definitions.

        Parameters:
        - symbolNames: (required) One or more target symbol names to search for definitions. Separate each symbol name with a comma.

        Usage:
        <search_definitions>
          <symbolNames>SymbolName1,SymbolName2</symbolNames>
        </search_definitions>


        Examples:

        1. Querying the definition of a single symbol:
        <search_definitions>
          <symbolNames>QueryCallGraphOptions</symbolNames>
        </search_definitions>

        2. Querying multiple symbols (within the 8-symbol limit)
        <search_definitions>
          <symbolNames>countFilesAndSize,RelationNode,defaultCacheCapacity</symbolNames>
        </search_definitions>

        IMPORTANT: You MUST follow this Efficient Symbol Defini Definition Strategy:
        - You MUST query all related symbols in one go whenever possible (up to 8 symbols per operation).
        - You MUST NOT split the request into multiple queries if they can be searched in a single batch operation.
        - You MUST obtain all necessary context before analyzing or modifying code
        - You MUST obtain complete definition information for each referenced symbol
        - You MUST prioritize the most critical symbols first when querying multiple symbols
        - You MUST write each symbol name in PLAIN form (e.g., types.QueryCallGraphOptions → QueryCallGraphOptions), omitting any package, namespace, or class prefixes.
        - You MUST use subsequent queries for additional symbols if more than 8 need to be analyzed

        **When to Use:**
        - You need to check a symbol's full definition before editing, reviewing, or refactoring code.
        - You need to analyze a symbol's structure, logic (across files/modules) and require its definition.
        - You're troubleshooting bugs or security issues and need to understand a symbol's implementation via its definition.
        - You plan to modify a function, method, class, or constant and need its definition to assess impact.
        - You're building code context (e.g., understanding code logic) and need definitions of referenced symbols.

        **When NOT to Use:**
        - The task is minor code editing that doesn't require a symbol's complete definition.
        - The request is exploratory or informational, with no specific symbol to look up the definition for.
        - You don't have a specific symbol name to look up its definition (the tool relies on a clear symbol name to work).
      
      capability: |
        - You can use the search_definitions tool to retrieve the complete definitions and implementations of one or more specified symbols (such as constants,functions, classes, methods, interfaces, and structs) by providing their symbol names. This is particularly useful when you need to understand the detailed structure and logic of a symbol, or to gather the definitions of referenced symbols to build a more complete context within the codebase. You may need to call this tool multiple times to examine different symbols relevant to your task.
            - For example, when asked to make edits, review code, investigate bugs, analyze code, or refactor code, you might first use search_definitions to obtain the full definitions and implementations of symbols referenced within the code, in order to supplement the context and fully understand the logic. Then, analyze the structure and behavior based on the gathered definitions. If understanding how a function or method is used throughout the codebase—including how its parameters are passed, validated, and propagated in higher-level calls—is valuable for tasks such as code review or refactoring, you can use search_references to find where it is referenced in other files or modules.
            - For example, when asked to retrieve symbol definitions, use this tool to obtain results more quickly, accurately, and with lower token cost.
            - For example, when asked to retrieve, find, show, or explain specific symbol definitions such as "show me the UserService class" or "what does the calculateTax function do", you should use search_definitions to obtain results more quickly, accurately, and with lower token cost compared to searching through files manually.
      
      rule: |
        - Don't use search_files to search for symbol definitions or call chains. It is highly inefficient, consumes excessive tokens, and returns imprecise results.
        - If the search failed, don't say "failed", describe this outcome as "did not find relevant results" instead.
        - When you need to retrieve a symbol's definition, first use the search_definitions tool. This tool allows you to efficiently obtain the full definition and implementation of functions, methods, classes, interfaces, structs, or constants across the project. search_definitions is precise and consumes fewer tokens than manually searching files, providing complete and context-rich results.
        - *IMPORTANT*: The search_definitions tool may return multiple definitions for symbols with the same name. You must use context and the provided information to determine and output the most accurate symbol definition.

      endpoints:
        search: "http://127.0.0.1:9001/codebase-indexer/api/v1/search/definition"
        ready: "http://127.0.0.1:9001/codebase-indexer/api/v1/index/summary"
      
      method: "GET"
      
      parameters:
        - name: "symbolNames"
          type: "string"
          description: "One or more target symbol names to search for definitions. Separate each symbol name with a comma."
          required: false
          source: "llm"
                  
    # 引用搜索工具
    - name: "search_references"
      description: |
        Description: Retrieves the reverse call chain (caller chain) for a specified function or method within the codebase.
        Given the name of a function or method, this tool traces all other functions or methods that directly or indirectly invoke it, providing a clear and context-rich view of its upstream dependencies.
        You can specify a lineRange to precisely locate the target function or method, improving both the accuracy and efficiency of call chain generation.
        This helps developers understand how a function or method is used, its relationships, and its dependency paths across the codebase.

        **IMPORTANT: This only applies to seven languages: Java, Go, Python, C, CPP, JavaScript, and TypeScript. Other languages are not applicable.

        Parameters:
        - filePath: (required) The path of the file where the function or method is defined (relative to workspace directory)
        - maxLayer: (required) Maximum call chain depth to search (default: 4, maximum: 10)
        - symbolName: (required) The name of the function or method 
        - lineRange: (optional) The line range of the function or method definition in format "start-end" (1-based)

        Usage:

        <search_references>
          <filePath>path/to/file</filePath>
          <maxLayer>call chain depth (1-10)</maxLayer>
          <symbolName>symbol name</symbolName>
          <lineRange>start-end</lineRange>
        </search_references>

        Examples
        1. Exploring reverse call chain of the queryCallGraphBySymbol function 
        <search_references>
          <filePath>internal\service\indexer.go</filePath>
          <maxLayer>4</maxLayer>
          <symbolName>queryCallGraphBySymbol</symbolName>
        </search_references>

        2. Exploring reverse call chain of the queryCallGraphByLineRange function with lineRange:
        <search_references>
          <filePath>internal\tokenizer\tokenizer.go</filePath>
          <maxLayer>5</maxLayer>
          <symbolName>queryCallGraphByLineRange</symbolName>
          <lineRange>20-75</lineRange>
        </search_references>

      capability: |
        - You can use search_references to retrieve comprehensive usage and call information for functions and methods across the entire codebase. This tool is particularly useful when you need to locate all usages and trace reverse call chains (caller chains) of a function or method, or when analyzing code dependencies across different modules and files. Compared to manually navigating directory structures and reading file contents, this tool provides a significantly faster and more accurate way to understand calling relationships between different functions and methods.
          - For example, when asked to review code snippets, investigate bugs, or analyze code, you MUST use search_references to obtain the reverse call chain of a function or method to understand how its parameters are passed, validated, and propagated in higher-level calls, which is critical because bugs are often caused by incorrect upstream parameter passing rather than the function itself, and without checking callers you might miss that a security vulnerability exists in how upstream code passes unvalidated input or that performance issues stem from callers invoking the function too frequently in wrong contexts.
          - For example, when asked to refactor code, you must use search_references to obtain the reverse call chain of a function or method before making any changes to identify all call sites that need modification when changing function signatures, assess backward compatibility requirements, and understand different calling patterns to ensure the refactored version handles all cases, because refactoring without checking callers first will break existing functionality across potentially dozens of call sites.

      rule: |
        - When analyzing a function or method's usage across the project, first use search_references to obtain its reverse call chain. This tool allows you to efficiently locate all places where the symbol is called or referenced, including parameter propagation and higher-level dependencies. This is especially useful for bug investigation, performance analysis, security checks, and refactoring, as issues often arise from incorrect or frequent calls upstream rather than the function itself. 
        - *IMPORTANT*: The search_references tool may return call chains that include functions with the same name. You must use context and the provided information to determine and output the most accurate call chain.

      endpoints:
        search: "http://127.0.0.1:9001/codebase-indexer/api/v1/callgraph"
        ready: "http://127.0.0.1:9001/codebase-indexer/api/v1/index/summary"
      
      method: "GET"
      
      parameters:
        - name: "filePath"
          type: "string"
          description: "The path of the file where the function or method is defined (relative to workspace directory)"
          required: true
          source: "llm"
          
        - name: "symbolName"
          type: "string"
          description: "The name of the function or method"
          required: true
          source: "llm"
          
        - name: "lineRange"
          type: "string"
          description: "The line range of the function or method definition in format \"start-end\" (1-based)"
          required: false
          source: "llm"
          
        - name: "maxLayer"
          type: "integer"
          description: "Maximum call chain depth to search (default: 4, maximum: 10)"
          required: true
          source: "llm"

# Forward configuration
# 不做对请求不做任何处理，只做记录，可用来抓包
forward:
  # Enable forwarding interface
  enabled: true
  # Default target URL for forwarding (optional)
  # If not provided, target URL must be specified in query parameter
  # defaultTarget: "http://zgsm.sangfor.com/"